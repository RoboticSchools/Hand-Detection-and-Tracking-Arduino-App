<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hand Detection and Tracking - Arduino + micro:bit</title>

  <link rel="preconnect" href="https://cdn.jsdelivr.net" />

  <style>
    :root{
      --bg: #0d0f12;
      --panel: #0f1115;
      --card: rgba(255,255,255,0.03);
      --muted: #9fdfff;
      --accent: linear-gradient(90deg,#00c3ff,#00ffa3);
      --glass: rgba(255,255,255,0.03);
      --radius: 14px;
      --gap: 14px;
      --fw-bold: 800;
      --payload-color: #00e0ff;
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:#eafcff;font-family:Inter,Segoe UI,Arial,sans-serif; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
    a{color:inherit}

    .top-header { position: fixed; top: 25px; left: 25px; z-index:100; display:flex; align-items:center; gap:10px; }
    .logo { height:55px ; width:auto; cursor:pointer; transition:transform .18s ease; }
    .logo:hover{ transform:scale(1.04); }

    .container{max-width:1180px;margin:80px auto;padding:18px;display:grid;grid-template-columns:1fr 340px;gap:var(--gap);align-items:start}
    header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;gap:12px}
    .title{display:flex;flex-direction:column;gap:4px}
    h1{margin:0;font-size:20px;font-weight:var(--fw-bold)}
    p.lead{margin:0;color:#9fdfff88;font-size:13px}

    .controls{display:flex;gap:10px;align-items:center}
    .btn{
      padding:10px 14px;border-radius:12px;border:0;font-weight:700;cursor:pointer;
      background:var(--glass); color: #dffcff; backdrop-filter: blur(6px);
    }
    .btn.primary{
      background: var(--accent); color: #032022;
      box-shadow: 0 6px 24px rgba(0,195,255,0.08), inset 0 -2px 0 rgba(0,0,0,0.12);
    }
    .status{
      background:var(--card); padding:8px 10px;border-radius:10px;color:var(--muted);font-weight:700;font-size:13px;
    }

    .video-wrap{background:#000;border-radius:var(--radius);overflow:hidden;min-height:380px;display:flex;flex-direction:column}
    .canvas-wrap{position:relative;width:100%;height:100%}
    canvas#output{display:block;width:100%;height:auto;background:#000}
    video#inputVideo{display:none}

    aside.panel{display:flex;flex-direction:column;gap:12px}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015));
      padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.02);
      box-shadow: 0 6px 20px rgba(0,0,0,0.6);
    }
    .stat-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
    .stat{
      background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;font-weight:800;display:flex;flex-direction:column;gap:6px;
    }
    .stat .label{font-size:12px;color:#bfefff}
    .stat .value{font-size:18px}

    .frame{
      background: rgba(255,255,255,0.02);
      border-radius:10px;padding:12px;backdrop-filter: blur(6px);
    }
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; color:var(--payload-color); word-break:break-word; font-size:24px; font-weight:800; text-align:center;}

    .small{font-size:12px;color:#9fdfff88}

    @media (max-width:980px){
      .container{grid-template-columns:1fr;padding:14px}
      aside.panel{order:2}
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>
  <header class="top-header">
    <img src="logo.png" alt="Robotic Schools Logo" class="logo">
  </header>

  <div class="container">
    <header>
      <div class="title">
        <h1>Hand Detection and Tracking - Arduino App</h1>
      </div>

      <div class="controls" aria-hidden="false">
        <button id="connectArduinoBtn" class="btn primary" title="Connect / Disconnect Arduino">Connect Arduino</button>
        <button id="connectMicrobitBtn" class="btn primary" title="Connect / Disconnect micro:bit">Connect micro:bit</button>
        <div id="connStatus" class="status" role="status" aria-live="polite">Not connected</div>
        <div id="microbitStatus" class="status" role="status" aria-live="polite" style="display:none;margin-left:6px">micro:bit: Not connected</div>
      </div>
    </header>

    <main class="video-wrap" aria-label="Camera preview and hand overlay">
      <div class="canvas-wrap">
        <canvas id="output" width="1280" height="720" aria-hidden="false"></canvas>
        <video id="inputVideo" autoplay playsinline muted></video>
      </div>
    </main>

    <aside class="panel" aria-label="Hand status panel">
      <div class="card">
        <div class="small" style="font-weight:800;margin-bottom:8px">Detection</div>
        <div class="stat-grid">
          <div class="stat frame">
            <div class="label">Hands</div>
            <div id="handsCount" class="value">0</div>
          </div>

          <div class="stat frame">
            <div class="label">Type</div>
            <div id="handsType" class="value">—</div>
          </div>

          <div class="stat frame" style="grid-column:1/-1">
            <div class="label">Fingers (total)</div>
            <div id="fingersCount" class="value">—</div>
          </div>
        </div>
      </div>

      <div class="card frame">
        <div style="font-weight:800;margin-bottom:8px">Sent to Device</div>
        <div id="lastPayload" class="mono">—</div>
      </div>

      <div class="card small">
        <div><strong>Notes:</strong></div>
        <ul style="margin:8px 0 0 16px;padding:0">
          <li>Use Chrome/Edge for Web Serial and Web Bluetooth support.</li>
        </ul>
      </div>
    </aside>
  </div>

  <script>
    const connectArduinoBtn = document.getElementById('connectArduinoBtn');
    const connectMicrobitBtn = document.getElementById('connectMicrobitBtn');
    const connStatus = document.getElementById('connStatus');
    const microbitStatus = document.getElementById('microbitStatus');
    const canvas = document.getElementById('output');
    const videoEl = document.getElementById('inputVideo');
    const handsCountEl = document.getElementById('handsCount');
    const handsTypeEl = document.getElementById('handsType');
    const fingersCountEl = document.getElementById('fingersCount');
    const lastPayloadEl = document.getElementById('lastPayload');
    const canvasCtx = canvas.getContext('2d', { alpha: false });
    const MIRROR_PREVIEW = true;
    const encoder = new TextEncoder();

    function updateButtonsVisibility() {
      if (serialConnected) {
        connectMicrobitBtn.style.display = 'none';
        microbitStatus.style.display = 'none';
        connStatus.style.display = '';
      } else if (bleConnected) {
        connectArduinoBtn.style.display = 'none';
        connStatus.style.display = 'none';
        microbitStatus.style.display = '';
      } else {
        connectMicrobitBtn.style.display = '';
        connectArduinoBtn.style.display = '';
        connStatus.style.display = '';
        microbitStatus.style.display = 'none';
      }
    }

    let port = null;
    let writer = null;
    let serialConnected = false;
    let writeQueue = Promise.resolve();
    function queueOp(op){ writeQueue = writeQueue.then(op, op); return writeQueue; }

    async function connectArduino(){
      if (serialConnected) { await disconnectArduino(); return; }
      if (!('serial' in navigator)) {
        alert('Web Serial API not supported in this browser. Use Chrome or Edge.');
        return;
      }
      try {
        connectArduinoBtn.textContent = 'Requesting port...';
        connStatus.textContent = 'Requesting port...';
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        serialConnected = true;
        connStatus.textContent = 'Connected';
        connectArduinoBtn.textContent = 'Disconnect';
        updateButtonsVisibility();
        readLoop().catch(()=>{});
      } catch (err) {
        serialConnected = false;
        connStatus.textContent = 'Not connected';
        connectArduinoBtn.textContent = 'Connect Arduino';
        alert('Failed to open serial port.');
        console.error('Serial connect error', err);
        updateButtonsVisibility();
      }
    }

    async function disconnectArduino(){
      connectArduinoBtn.textContent = 'Disconnecting...';
      connStatus.textContent = 'Disconnecting...';
      try { if (writer) { await writer.close(); writer.releaseLock(); writer = null; } } catch(e) {}
      try { if (port) await port.close(); } catch(e) {}
      port = null; serialConnected = false;
      connStatus.textContent = 'Not connected';
      connectArduinoBtn.textContent = 'Connect Arduino';
      updateButtonsVisibility();
    }

    async function readLoop(){
      if (!port || !port.readable) return;
      const reader = port.readable.getReader();
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
        }
      } catch (e) {} finally { try { reader.releaseLock(); } catch(e){} }
    }

    function sendSerialLine(line){
      if (!serialConnected || !writer) return;
      return queueOp(async () => {
        try { await writer.write(encoder.encode(line + '\n')); } catch (e) { console.warn('Serial write error', e); }
      });
    }

    connectArduinoBtn.addEventListener('click', connectArduino);

    const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_NOTIFY_CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_WRITE_CHAR_UUID  = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

    let bleDevice = null;
    let bleServer = null;
    let uartService = null;
    let notifyChar = null;
    let writeChar = null;
    let bleConnected = false;
    let bleWriteQueue = Promise.resolve();
    const MAX_RECONNECT_ATTEMPTS = 8;
    let reconnectAttempts = 0;

    function queueGattOperation(op){ bleWriteQueue = bleWriteQueue.then(op, op); return bleWriteQueue; }
    function safeLog(...args){ console.log('[BLE]', ...args); }

    async function connectMicrobit(){
      if (bleConnected) { await disconnectMicrobit(); return; }
      if (!('bluetooth' in navigator)) {
        alert('Web Bluetooth API not supported in this browser. Use Chrome/Edge on desktop or a supported mobile browser.');
        return;
      }
      try {
        microbitStatus.style.display = '';
        microbitStatus.textContent = 'Requesting micro:bit...';
        bleDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'BBC micro:bit' }],
          optionalServices: [UART_SERVICE_UUID]
        });
        if(!bleDevice) throw new Error('No device selected');
        bleDevice.addEventListener('gattserverdisconnected', handleDisconnected);
        microbitStatus.textContent = `Device: ${bleDevice.name || 'micro:bit'}`;

        microbitStatus.textContent = 'Connecting...';
        bleServer = await bleDevice.gatt.connect();

        microbitStatus.textContent = 'Getting UART service...';
        uartService = await bleServer.getPrimaryService(UART_SERVICE_UUID);

        microbitStatus.textContent = 'Getting characteristics...';
        writeChar = await uartService.getCharacteristic(UART_WRITE_CHAR_UUID).catch(()=>null);
        notifyChar = await uartService.getCharacteristic(UART_NOTIFY_CHAR_UUID).catch(()=>null);
        if(notifyChar && (notifyChar.properties.notify || notifyChar.properties.indicate)){
          await notifyChar.startNotifications();
          notifyChar.addEventListener('characteristicvaluechanged', onNotify);
        }

        bleConnected = true;
        reconnectAttempts = 0;
        microbitStatus.textContent = `Connected: ${bleDevice.name || 'micro:bit'}`;
        connectMicrobitBtn.textContent = 'Disconnect';
        updateButtonsVisibility();
      } catch (err) {
        console.error('Connect failed', err);
        microbitStatus.textContent = 'micro:bit: connection failed';
        microbitStatus.style.color = '#ff6b6b';
        bleDevice = null;
        bleConnected = false;
        connectMicrobitBtn.textContent = 'Connect micro:bit';
        updateButtonsVisibility();
      }
    }

    async function disconnectMicrobit(){
      connectMicrobitBtn.textContent = 'Disconnecting...';
      try { if (notifyChar && notifyChar.stopNotifications) await notifyChar.stopNotifications(); } catch(e){}
      try { if (bleDevice && bleDevice.gatt && bleDevice.gatt.connected) bleDevice.gatt.disconnect(); } catch(e){}
      bleDevice = null; bleServer = null; writeChar = null; notifyChar = null;
      bleConnected = false;
      connectMicrobitBtn.textContent = 'Connect micro:bit';
      microbitStatus.textContent = 'micro:bit: Not connected';
      microbitStatus.style.display = 'none';
      updateButtonsVisibility();
    }

    function handleDisconnected(event){
      const dev = event.target;
      safeLog(`Device ${dev.name} disconnected`);
      bleConnected = false;
      microbitStatus.textContent = 'Disconnected — attempting reconnect...';
      microbitStatus.style.color = '#ffcc66';
      attemptReconnect();
    }

    function attemptReconnect(){
      if(!bleDevice){ microbitStatus.textContent = 'Not connected'; connectMicrobitBtn.textContent = 'Connect micro:bit'; microbitStatus.style.display = 'none'; updateButtonsVisibility(); return; }
      reconnectAttempts++;
      if(reconnectAttempts > MAX_RECONNECT_ATTEMPTS){
        microbitStatus.textContent = 'Reconnect failed — click Connect';
        connectMicrobitBtn.textContent = 'Connect micro:bit';
        microbitStatus.style.color = '#ff6b6b';
        bleDevice = null;
        bleConnected = false;
        updateButtonsVisibility();
        return;
      }
      const backoffMs = Math.min(1000 * Math.pow(2, reconnectAttempts-1), 20000);
      safeLog('Reconnect attempt', reconnectAttempts, 'next in ms', backoffMs);
      setTimeout(async () => {
        try {
          microbitStatus.textContent = `Reconnect attempt ${reconnectAttempts}...`;
          bleServer = await bleDevice.gatt.connect();
          uartService = await bleServer.getPrimaryService(UART_SERVICE_UUID);
          writeChar = await uartService.getCharacteristic(UART_WRITE_CHAR_UUID).catch(()=>null);
          notifyChar = await uartService.getCharacteristic(UART_NOTIFY_CHAR_UUID).catch(()=>null);
          if(notifyChar && (notifyChar.properties.notify || notifyChar.properties.indicate)){
            await notifyChar.startNotifications();
            notifyChar.addEventListener('characteristicvaluechanged', onNotify);
          }
          bleConnected = true;
          reconnectAttempts = 0;
          microbitStatus.textContent = `Reconnected: ${bleDevice.name || 'micro:bit'}`;
          connectMicrobitBtn.textContent = 'Disconnect';
          updateButtonsVisibility();
        } catch(e){
          console.warn('Reconnect attempt failed', e);
          attemptReconnect();
        }
      }, backoffMs);
    }

    function onNotify(ev){
      const value = ev.target.value;
      const text = new TextDecoder().decode(value);
      safeLog('Notified:', text);
    }

    function sendUARTRaw(bytes){
      if(!writeChar){
        safeLog('No write characteristic - cannot send');
        microbitStatus.textContent = 'Not writable - reconnect or check micro:bit firmware';
        microbitStatus.style.color = '#ff6b6b';
        return Promise.reject(new Error('No write characteristic'));
      }
      return queueGattOperation(async () => {
        try {
          if(typeof writeChar.writeValue === 'function'){
            await writeChar.writeValue(bytes);
          } else if(typeof writeChar.writeValueWithoutResponse === 'function'){
            await writeChar.writeValueWithoutResponse(bytes);
          } else {
            if(writeChar.properties && writeChar.properties.writeWithoutResponse && typeof writeChar.writeValue === 'function'){
              await writeChar.writeValue(bytes);
            } else {
              throw new Error('No writable method on characteristic');
            }
          }
          safeLog('Sent bytes', bytes);
        } catch (err){
          console.error('Write failed', err);
          throw err;
        }
      });
    }

    async function sendToMicrobit(text){
      if(!bleConnected || !writeChar){
        safeLog('Skipped send - not connected or writable');
        return;
      }
      try {
        const payload = encoder.encode(String(text) + '\n');
        await sendUARTRaw(payload);
      } catch(e){
        console.error('sendToMicrobit error', e);
      }
    }

    connectMicrobitBtn.addEventListener('click', connectMicrobit);

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    let camera = null;
    async function startCamera(){
      try {
        camera = new Camera(videoEl, {
          onFrame: async () => { await hands.send({ image: videoEl }); },
          width: 1280,
          height: 720,
          facingMode: 'user'
        });
        await camera.start();
        canvas.width = videoEl.videoWidth || 1280;
        canvas.height = videoEl.videoHeight || 720;
      } catch (err) {
        console.error('Camera start failed:', err);
      }
    }
    startCamera().catch((e)=>{ console.error('startCamera error', e); });

    function countFingers(landmarks, handednessLabel){
      if (!landmarks || landmarks.length === 0) return 0;
      const tips = [4,8,12,16,20];
      const pips = [2,6,10,14,18];
      let cnt = 0;
      for (let i = 1; i < 5; i++){
        if (landmarks[tips[i]].y < landmarks[pips[i]].y - 0.01) cnt++;
      }
      const tipThumb = landmarks[4], ipThumb = landmarks[3];
      if (handednessLabel){
        const label = handednessLabel.toLowerCase();
        if (label === 'right'){
          if (tipThumb.x < ipThumb.x - 0.02) cnt++;
        } else {
          if (tipThumb.x > ipThumb.x + 0.02) cnt++;
        }
      } else {
        if (Math.abs(tipThumb.x - ipThumb.x) > 0.04) cnt++;
      }
      return cnt;
    }

    function drawResultsOnCanvas(results){
      const w = canvas.width, h = canvas.height;
      canvasCtx.save();
      canvasCtx.clearRect(0,0,w,h);

      if (MIRROR_PREVIEW){
        canvasCtx.translate(w,0);
        canvasCtx.scale(-1,1);
        canvasCtx.drawImage(videoEl, 0, 0, w, h);
        canvasCtx.restore();

        if (!results.multiHandLandmarks) return;
        for (let i = 0; i < results.multiHandLandmarks.length; i++){
          const lm = results.multiHandLandmarks[i];
          const connections = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],
            [0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20]
          ];
          canvasCtx.strokeStyle = 'rgba(0,255,204,0.95)';
          canvasCtx.lineWidth = Math.max(1, Math.round(w / 640));
          for (const [a,b] of connections){
            const ax = w * (1 - lm[a].x), ay = h * lm[a].y;
            const bx = w * (1 - lm[b].x), by = h * lm[b].y;
            canvasCtx.beginPath();
            canvasCtx.moveTo(ax, ay);
            canvasCtx.lineTo(bx, by);
            canvasCtx.stroke();
          }
          canvasCtx.fillStyle = 'rgba(255,184,107,0.95)';
          for (let j = 0; j < lm.length; j++){
            const x = w * (1 - lm[j].x), y = h * lm[j].y;
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, Math.max(3, Math.round(w / 640) * 2), 0, Math.PI * 2);
            canvasCtx.fill();
          }
        }
      } else {
        canvasCtx.drawImage(videoEl, 0, 0, w, h);
        canvasCtx.restore();

        if (!results.multiHandLandmarks) return;
        for (let i = 0; i < results.multiHandLandmarks.length; i++){
          const lm = results.multiHandLandmarks[i];
          const connections = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],
            [0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20]
          ];
          canvasCtx.strokeStyle = 'rgba(0,255,204,0.95)';
          canvasCtx.lineWidth = Math.max(1, Math.round(w / 640));
          for (const [a,b] of connections){
            const ax = w * lm[a].x, ay = h * lm[a].y;
            const bx = w * lm[b].x, by = h * lm[b].y;
            canvasCtx.beginPath();
            canvasCtx.moveTo(ax, ay);
            canvasCtx.lineTo(bx, by);
            canvasCtx.stroke();
          }
          canvasCtx.fillStyle = 'rgba(255,184,107,0.95)';
          for (let j = 0; j < lm.length; j++){
            const x = w * lm[j].x, y = h * lm[j].y;
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, Math.max(3, Math.round(w / 640) * 2), 0, Math.PI * 2);
            canvasCtx.fill();
          }
        }
      }
    }

    function flipLabel(label){
      if (!label) return label;
      if (label === 'Left') return 'Right';
      if (label === 'Right') return 'Left';
      return label;
    }

    let lastSent = null;
    function buildPayloadCompact(handCount, typeChar, fingerCount){
      return `${handCount},${typeChar},${fingerCount}`;
    }

    function onResults(results){
      drawResultsOnCanvas(results);
      const handsDetected = (results.multiHandLandmarks || []).length;
      handsCountEl.textContent = handsDetected;
      let typeChar = 'U';
      let fingersTotal = 0;

      if (handsDetected === 1){
        const rawLabel = results.multiHandedness && results.multiHandedness[0] ? results.multiHandedness[0].label : null;
        const displayLabel = MIRROR_PREVIEW ? flipLabel(rawLabel) : rawLabel;
        const labelChar = displayLabel ? displayLabel.charAt(0).toUpperCase() : 'U';
        typeChar = (labelChar === 'L' || labelChar === 'R') ? labelChar : 'U';
        fingersTotal = countFingers(results.multiHandLandmarks[0], rawLabel);
      } else if (handsDetected === 2){
        typeChar = 'B';
        for (let i = 0; i < 2; i++){
          const rawLabel = results.multiHandedness && results.multiHandedness[i] ? results.multiHandedness[i].label : null;
          fingersTotal += countFingers(results.multiHandLandmarks[i], rawLabel);
        }
      } else {
        typeChar = 'N';
        fingersTotal = 0;
      }

      const typeText = typeChar === 'B' ? 'Both' : (typeChar === 'N' ? 'None' : (typeChar === 'U' ? 'Unknown' : (typeChar === 'L' ? 'Left' : 'Right')));
      handsTypeEl.textContent = typeText;
      fingersCountEl.textContent = fingersTotal;

      const payload = buildPayloadCompact(handsDetected, typeChar, fingersTotal);
      if (lastSent !== payload){
        lastSent = payload;
        lastPayloadEl.textContent = payload;

        if (serialConnected) {
          sendSerialLine(payload);
        } else if (bleConnected) {
          sendToMicrobit(payload).catch(e=>console.warn('BLE send failed', e));
        }
      }
    }

    window.addEventListener('beforeunload', async () => {
      try { if (writer) { await writer.close(); writer = null; } if (port) { await port.close(); } } catch (e) {}
      try { if (notifyChar && notifyChar.stopNotifications) await notifyChar.stopNotifications(); } catch(e){}
      try { if (bleDevice && bleDevice.gatt && bleDevice.gatt.connected) bleDevice.gatt.disconnect(); } catch(e){}
    });

    const stateMonitorInterval = setInterval(() => {
      if (bleDevice && bleDevice.gatt) {
        const nowBle = !!bleDevice.gatt.connected;
        if (nowBle !== bleConnected) {
          bleConnected = nowBle;
          microbitStatus.style.display = bleConnected ? '' : 'none';
          microbitStatus.textContent = bleConnected ? `Connected: ${bleDevice.name || 'micro:bit'}` : 'micro:bit: Not connected';
          connectMicrobitBtn.textContent = bleConnected ? 'Disconnect' : 'Connect micro:bit';
          updateButtonsVisibility();
        }
      }
      if (serialConnected) {
        connStatus.style.display = '';
        connStatus.textContent = 'Connected to Arduino';
        connectArduinoBtn.textContent = 'Disconnect';
      } else {
        if (!bleConnected) {
          connStatus.style.display = '';
          connStatus.textContent = 'Not connected';
        } else {
          connStatus.style.display = 'none';
        }
        connectArduinoBtn.textContent = 'Connect Arduino';
      }
      updateButtonsVisibility();
    }, 1500);

  </script>
</body>
</html>
